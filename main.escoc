-- This does not type check because it lacks a whnf

inconsistent
: {P : Type} P
= inconsistent

-- Identity

the
: {A : Type} {u : A} A
= [A] [u] u

-- A self-referential type

Self
: {T : (Self T)} Type
= [T] {self : (T self)} Type

-- The empty, uninhabited type

Empty
: (Self Empty)
= [self]
  {Prop : {self : (Empty self)} Type}
  (Prop self)

-- The unit type

Unit
: (Self Unit)
= [self]
  {Prop : (Self Unit)}
  {new  : (Prop Unit.new)}
  (Prop self)

Unit.new
: (Unit Unit.new)
= [Prop] [new] new

-- The booleans true and false

Bool
: (Self Bool)
= [self]
  {Prop  : (Self Bool)}
  {true  : (Prop Bool.true)}
  {false : (Prop Bool.false)}
  (Prop self)

Bool.true
: (Bool Bool.true)
= [Prop] [true] [false] true

Bool.false
: (Bool Bool.false)
= [Prop] [true] [false] false

Bool.induct
: {self  : (Bool self)}
  {Prop  : (Self Bool)}
  {true  : (Prop Bool.true)}
  {false : (Prop Bool.false)}
  (Prop self)
= [self] [Prop] [true] [false]
  (self Prop true false)

Bool.not
: {self : (Bool self)} (Bool (Bool.not self))
= [self]
  (self
    [self](Bool (Bool.not self))
    Bool.false
    Bool.true)

-- Natural numbers

Nat
: (Self Nat)
= [self]
  {Prop  : (Self Nat)}
  {succ  : {pred : (Nat pred)} (Prop (Nat.succ pred))}
  {zero  : (Prop Nat.zero)}
  (Prop self)

Nat.succ
: {pred : (Nat pred)} (Nat (Nat.succ pred))
= [pred] [Nat.] [succ.] [zero.]
  (succ. pred)

Nat.zero
: (Nat Nat.zero)
= [Nat.] [succ.] [zero.] zero.

Nat.0 : (Nat Nat.0) = Nat.zero
Nat.1 : (Nat Nat.1) = (Nat.succ Nat.0)
Nat.2 : (Nat Nat.2) = (Nat.succ Nat.1)
Nat.3 : (Nat Nat.3) = (Nat.succ Nat.2)
Nat.4 : (Nat Nat.4) = (Nat.succ Nat.3)
Nat.5 : (Nat Nat.5) = (Nat.succ Nat.4)
Nat.6 : (Nat Nat.6) = (Nat.succ Nat.5)
Nat.7 : (Nat Nat.7) = (Nat.succ Nat.6)
Nat.8 : (Nat Nat.8) = (Nat.succ Nat.7)
Nat.9 : (Nat Nat.9) = (Nat.succ Nat.8)

Nat.id
: {a : (Nat a)} (Nat (Nat.id a))
= [a]
  (a [a] (Nat (Nat.id a))
    [pred : (Nat pred)] (Nat.succ (Nat.id pred))
    Nat.zero)

Nat.same
: {a : (Nat a)} (Nat (Nat.same a))
= [a] [Prop] [succ] [zero]
  (a [a] (Prop (Nat.same a))
    [pred : (Nat pred)] (succ (Nat.same pred))
    zero)

Nat.double
: {n : (Nat n)} (Nat (Nat.double n))
= [n]
  (n [n] (Nat (Nat.double n))
    [pred : (Nat pred)] (Nat.succ (Nat.succ (Nat.double pred)))
    Nat.zero)

Nat.add
: {a : (Nat a)} {b : (Nat b)} (Nat (Nat.add a b))
= [a] [b]
  (a [a] (Nat (Nat.add a b))
    [~a : (Nat ~a)] (Nat.succ (Nat.add ~a b))
    b)

Nat.add_n_zero
: {n : (Nat n)} (Eq Nat (Nat.add n Nat.zero) n (Nat.add_n_zero n))
= [n]
  (n [self](Eq Nat (Nat.add self Nat.zero) self (Nat.add_n_zero self))
    [pred : (Nat pred)] (Eq.cong Nat Nat (Nat.add pred Nat.zero) pred (Nat.add_n_zero pred) Nat.succ)
    (Eq.refl Nat Nat.zero))

Nat.add_n_succ_m
: {n : (Nat n)} {m : (Nat m)} (Eq Nat (Nat.add n (Nat.succ m)) (Nat.succ (Nat.add n m)) (Nat.add_n_succ_m n m))
= [N] [M]
  (N
    [self] (Eq Nat (Nat.add self (Nat.succ M)) (Nat.succ (Nat.add self M)) (Nat.add_n_succ_m self M))
    [pred : (Nat pred)]
      (Eq.cong
        Nat
        Nat
        (Nat.add pred (Nat.succ M))
        (Nat.succ (Nat.add pred M))
        (Nat.add_n_succ_m pred M)
        Nat.succ)
    (Eq.refl Nat (Nat.succ M)))

-- Equality on self-referential types

Eq
: {T    : (Self T)}
  {a    : (T a)}
  {b    : (T b)}
  {self : (Eq T a b self)}
  Type
= [T] [a] [b] [self]
  {Prop : {b : (T b)} {self : (Eq T a b self)} Type}
  {refl : (Prop a (Eq.refl T a))}
  (Prop b self)

Eq.refl
: {T : (Self T)}
  {a : (T a)}
  (Eq T a a (Eq.refl T a))
= [T] [a] [Prop] [refl]
  refl

Eq.sym
: {T : {self : (T self)} Type}
  {a : (T a)}
  {b : (T b)}
  {e : (Eq T a b e)}
  (Eq T b a (Eq.sym T a b e))
= [T] [a] [b] [e]
  (e [b][self](Eq T b a (Eq.sym T a b self))
    (Eq.refl T a))

Eq.cong
: {A : {self : (A self)} Type}
  {B : {self : (B self)} Type}
  {a : (A a)}
  {b : (A b)}
  {e : (Eq A a b e)}
  {f : {a : (A a)} (B (f a))}
  (Eq B (f a) (f b) (Eq.cong A B a b e f))
= [A] [B] [a] [b] [e] [f] 
  (e [b][self](Eq B (f a) (f b) (Eq.cong A B a b self f))
    (Eq.refl B (f a)))

Eq.subst
: {T : (Self T)}
  {a : (T a)}
  {b : (T b)}
  {e : (Eq T a b e)}
  {P : {a : (T a)} (Self (P a))}
  {x : (P a x)}
  (P b (Eq.subst T a b e P x))
= [T] [a] [b] [e] [P] [x]
  (e [b][self](P b (Eq.subst T a b self P x)) x)

-- Binary

Bin
: (Self Bin)
= [self]
  {Prop : (Self Bin)}
  {O    : {pred : (Bin pred)} (Prop (Bin.O pred))}
  {I    : {pred : (Bin pred)} (Prop (Bin.I pred))}
  {E    : (Prop Bin.E)}
  (Prop self)

Bin.O
: {pred : (Bin pred)}
  (Bin (Bin.O pred))
= [pred] [Prop] [O] [I] [E]
  (O pred)

Bin.I
: {pred : (Bin pred)}
  (Bin (Bin.I pred))
= [pred] [Prop] [O] [I] [E]
  (I pred)

Bin.E
: (Bin Bin.E)
= [Prop] [O] [I] [E]
  E

Bin.inc
: {x : (Bin x)}
  (Bin (Bin.inc x))
= [xs]
  (xs [self : (Bin self)] (Bin (Bin.inc self))
    [pred] (Bin.I pred)
    [pred] (Bin.O (Bin.inc pred))
    Bin.E)

-- Dependent pairs

Sigma
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {self : (Sigma A B self)}
  Type
= [A] [B] [self]
  {Prop : {self : (Sigma A B self)} Type}
  {new  : {a : (A a)} {b : (B a b)} (Prop (Sigma.new A B a b))}
  (Prop self)

Sigma.new
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {a : (A a)}
  {b : (B a b)}
  (Sigma A B (Sigma.new A B a b))
= [A] [B] [a] [b] [Prop] [new]
  (new a b)

Sigma.fst
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {sigma : (Sigma A B sigma)}
  (A (Sigma.fst A B sigma))
= [A] [B] [sigma]
  (sigma
    [self : (Sigma A B self)](A (Sigma.fst A B self))
    [a : (A a)] [b : (B a b)] a)

Sigma.snd
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {sigma : (Sigma A B sigma)}
  (B (Sigma.fst A B sigma) (Sigma.snd A B sigma))
= [A] [B] [sigma]
  (sigma
    [self : (Sigma A B self)] (B (Sigma.fst A B self) (Sigma.snd A B self))
    [a : (A a)] [b : (B a b)] b)

Sigma.example
= (Sigma.new Nat [x : (Nat x)](Eq Nat x x) Nat.3 (Eq.refl Nat Nat.3))

-- Church Natural Numbers

Cat
: (Self Cat)
= [self]
  {P : (Self P)}
  {s : {x : (P x)} (P (s x))}
  {z : (P z)}
  (P (self P s z))

Cat.succ
: {n : (Cat n)} (Cat (Cat.succ n))
= [n] [P] [s] [z]
  (s (n P s z))

Cat.zero
: (Cat Cat.zero)
= [P] [s] [z]
  z

Cat.0 : (Cat Cat.0) = Cat.zero
Cat.1 : (Cat Cat.1) = (Cat.succ Cat.0)
Cat.2 : (Cat Cat.2) = (Cat.succ Cat.1)
Cat.3 : (Cat Cat.3) = (Cat.succ Cat.2)
Cat.4 : (Cat Cat.4) = (Cat.succ Cat.3)
Cat.5 : (Cat Cat.5) = (Cat.succ Cat.4)
Cat.6 : (Cat Cat.6) = (Cat.succ Cat.5)
Cat.7 : (Cat Cat.7) = (Cat.succ Cat.6)
Cat.8 : (Cat Cat.8) = (Cat.succ Cat.7)
Cat.9 : (Cat Cat.9) = (Cat.succ Cat.8)

Cat.add
: {n : (Cat n)} {m : (Cat m)} (Cat (Cat.add n m))
= [n] [m] [P] [s] [z]
  (n P s (m P s z))

Cat.mul
: {n : (Cat n)} {m : (Cat m)} (Cat (Cat.mul n m))
= [n] [m] [P] [s] [z]
  (n P (m P s) z)

Cat.ex
: (Eq Cat Cat.zero Cat.zero (Eq.refl Cat Cat.zero))
= (Eq.refl Cat Cat.zero)

Cat.even
: {n : (Cat n)} (Bool (Cat.even n))
= [n] 
  (n [n : (Bool n)](Bool n)
    [n : (Bool n)] (Bool.not n)
    Bool.true)

-- Nutural nambers (Parigot)

Nut
: {self : (Nut self)} Type
= [self]
  {Prop : {self : (Nut self)} Type}
  {succ : {pred : (Nut pred)} {fold : (Prop pred)} (Prop (Nut.succ pred))}
  {zero : (Prop Nut.zero)}
  (Prop self)

Nut.succ
: {pred : (Nut pred)} (Nut (Nut.succ pred))
= [pred] [Nut.] [succ.] [zero.]
  (succ. pred (pred Nut. succ. zero.))

Nut.zero
: (Nut Nut.zero)
= [Nut.] [succ.] [zero.] zero.

Nut.0 : (Nut Nut.0) = Nut.zero
Nut.1 : (Nut Nut.1) = (Nut.succ Nut.0)
Nut.2 : (Nut Nut.2) = (Nut.succ Nut.1)
Nut.3 : (Nut Nut.3) = (Nut.succ Nut.2)
Nut.4 : (Nut Nut.4) = (Nut.succ Nut.3)
Nut.5 : (Nut Nut.5) = (Nut.succ Nut.4)
Nut.6 : (Nut Nut.6) = (Nut.succ Nut.5)
Nut.7 : (Nut Nut.7) = (Nut.succ Nut.6)
Nut.8 : (Nut Nut.8) = (Nut.succ Nut.7)
Nut.9 : (Nut Nut.9) = (Nut.succ Nut.8)

Nut.add
: {n : (Nut n)}
  {m : (Nut m)}
  (Nut (Nut.add n m))
= [n] (n
  [self : (Nut self)] {m : (Nut m)} (Nut (Nut.add self m))
  [pred] [fold : {m : (Nut m)} (Nut (Nut.add pred m))] [m : (Nut m)] (fold (Nut.succ m))
  [m : (Nut m)] m)

Nut.double_aux
: {n : (Nut n)}
  {m : (Nut m)}
  (Nut (Nut.double_aux n m))
= [n] (n
  [self : (Nut self)]
    {m : (Nut m)} (Nut (Nut.double_aux self m))
  [pred] [fold : {m : (Nut m)} (Nut (Nut.double_aux pred m))]
    [m : (Nut m)] (fold (Nut.succ (Nut.succ m)))
  [m : (Nut m)] m)

Nut.double
: {n : (Nut n)}
  (Nut (Nut.double n))
= [n] (Nut.double_aux n Nut.zero)

Nut.to_cat
: {n : (Nut n)} (Cat (Nut.to_cat n))
= [n] (n
  [self : (Nut self)] (Cat (Nut.to_cat self))
  [pred]
    [fold : (Cat (Nut.to_cat pred))]
    [P : (Self P)]
    [s : {x : (P x)} (P (s x))]
    [z : (P z)]
    (fold P s (s z))
  Cat.zero)

Nut.from_cat
: {n : (Cat n)} (Nut (Nut.from_cat n))
= [n] (n Nut Nut.succ Nut.zero)

Nut.add2
: {n : (Nut n)} {m : (Nut m)} (Nut (Nut.add2 n m))
= [n] [m] (Nut.from_cat (Cat.add (Nut.to_cat n) (Nut.to_cat m)))

Nut.mul2
: {n : (Nut n)} {m : (Nut m)} (Nut (Nut.mul2 n m))
= [n] [m] (Nut.from_cat (Cat.mul (Nut.to_cat n) (Nut.to_cat m)))

main
= Nut.add2
